"use strict";(globalThis.webpackChunkgo_faster_docs=globalThis.webpackChunkgo_faster_docs||[]).push([[797],{3905:(t,e,n)=>{n.d(e,{Zo:()=>c,kt:()=>g});var r=n(7294);function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function a(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?a(Object(n),!0).forEach((function(e){o(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function l(t,e){if(null==t)return{};var n,r,o=function(t,e){if(null==t)return{};var n,r,o={},a=Object.keys(t);for(r=0;r<a.length;r++)n=a[r],e.indexOf(n)>=0||(o[n]=t[n]);return o}(t,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);for(r=0;r<a.length;r++)n=a[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(o[n]=t[n])}return o}var i=r.createContext({}),p=function(t){var e=r.useContext(i),n=e;return t&&(n="function"==typeof t?t(e):s(s({},e),t)),n},c=function(t){var e=p(t.components);return r.createElement(i.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},d=r.forwardRef((function(t,e){var n=t.components,o=t.mdxType,a=t.originalType,i=t.parentName,c=l(t,["components","mdxType","originalType","parentName"]),d=p(n),g=o,h=d["".concat(i,".").concat(g)]||d[g]||u[g]||a;return n?r.createElement(h,s(s({ref:e},c),{},{components:n})):r.createElement(h,s({ref:e},c))}));function g(t,e){var n=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var a=n.length,s=new Array(a);s[0]=d;var l={};for(var i in e)hasOwnProperty.call(e,i)&&(l[i]=e[i]);l.originalType=t,l.mdxType="string"==typeof t?t:o,s[1]=l;for(var p=2;p<a;p++)s[p]=n[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1585:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>i,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>p});var r=n(7462),o=(n(7294),n(3905));const a={id:"patterns",title:"Patterns",sidebar_position:5},s=void 0,l={unversionedId:"style-guide/patterns",id:"style-guide/patterns",title:"Patterns",description:"Test Tables",source:"@site/docs/style-guide/patterns.mdx",sourceDirName:"style-guide",slug:"/style-guide/patterns",permalink:"/docs/style-guide/patterns",editUrl:"https://github.com/go-faster/web/edit/main/docs/style-guide/patterns.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{id:"patterns",title:"Patterns",sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Style",permalink:"/docs/style-guide/style"},next:{title:"Intro",permalink:"/docs/clickhouse"}},i={},p=[{value:"Test Tables",id:"test-tables",level:2},{value:"Functional Options",id:"functional-options",level:2}],c={toc:p};function u(t){let{components:e,...n}=t;return(0,o.kt)("wrapper",(0,r.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"test-tables"},"Test Tables"),(0,o.kt)("p",null,"Use table-driven tests with ",(0,o.kt)("a",{parentName:"p",href:"https://blog.golang.org/subtests"},"subtests")," to avoid duplicating code when the core\ntest logic is repetitive."),(0,o.kt)("table",null,(0,o.kt)("thead",null,(0,o.kt)("tr",null,(0,o.kt)("th",null,"Bad"),(0,o.kt)("th",null,"Good"))),(0,o.kt)("tbody",null,(0,o.kt)("tr",null,(0,o.kt)("td",null,(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'// func TestSplitHostPort(t *testing.T)\n\nhost, port, err := net.SplitHostPort("192.0.2.0:8000")\nrequire.NoError(t, err)\nassert.Equal(t, "192.0.2.0", host)\nassert.Equal(t, "8000", port)\n\nhost, port, err = net.SplitHostPort("192.0.2.0:http")\nrequire.NoError(t, err)\nassert.Equal(t, "192.0.2.0", host)\nassert.Equal(t, "http", port)\n\nhost, port, err = net.SplitHostPort(":8000")\nrequire.NoError(t, err)\nassert.Equal(t, "", host)\nassert.Equal(t, "8000", port)\n\nhost, port, err = net.SplitHostPort("1:8")\nrequire.NoError(t, err)\nassert.Equal(t, "1", host)\nassert.Equal(t, "8", port)\n'))),(0,o.kt)("td",null,(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'// func TestSplitHostPort(t *testing.T)\n\ntests := []struct{\n  give     string\n  wantHost string\n  wantPort string\n}{\n  {\n    give:     "192.0.2.0:8000",\n    wantHost: "192.0.2.0",\n    wantPort: "8000",\n  },\n  {\n    give:     "192.0.2.0:http",\n    wantHost: "192.0.2.0",\n    wantPort: "http",\n  },\n  {\n    give:     ":8000",\n    wantHost: "",\n    wantPort: "8000",\n  },\n  {\n    give:     "1:8",\n    wantHost: "1",\n    wantPort: "8",\n  },\n}\n\nfor _, tt := range tests {\n  t.Run(tt.give, func(t *testing.T) {\n    host, port, err := net.SplitHostPort(tt.give)\n    require.NoError(t, err)\n    assert.Equal(t, tt.wantHost, host)\n    assert.Equal(t, tt.wantPort, port)\n  })\n}\n')))))),(0,o.kt)("p",null,"Test tables make it easier to add context to error messages, reduce duplicate\nlogic, and add new test cases."),(0,o.kt)("p",null,"We follow the convention that the slice of structs is referred to as ",(0,o.kt)("inlineCode",{parentName:"p"},"tests"),"\nand each test case ",(0,o.kt)("inlineCode",{parentName:"p"},"tt"),". Further, we encourage explicating the input and output\nvalues for each test case with ",(0,o.kt)("inlineCode",{parentName:"p"},"give")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"want")," prefixes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"tests := []struct{\n  give     string\n  wantHost string\n  wantPort string\n}{\n  // ...\n}\n\nfor _, tt := range tests {\n  // ...\n}\n")),(0,o.kt)("h2",{id:"functional-options"},"Functional Options"),(0,o.kt)("p",null,"Functional options is a pattern in which you declare an opaque ",(0,o.kt)("inlineCode",{parentName:"p"},"Option")," type\nthat records information in some internal struct. You accept a variadic number\nof these options and act upon the full information recorded by the options on\nthe internal struct."),(0,o.kt)("p",null,"Use this pattern for optional arguments in constructors and other public APIs\nthat you foresee needing to expand, especially if you already have three or\nmore arguments on those functions."),(0,o.kt)("table",null,(0,o.kt)("thead",null,(0,o.kt)("tr",null,(0,o.kt)("th",null,"Bad"),(0,o.kt)("th",null,"Good"))),(0,o.kt)("tbody",null,(0,o.kt)("tr",null,(0,o.kt)("td",null,(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// package db\n\nfunc Open(\n  addr string,\n  cache bool,\n  logger *zap.Logger\n) (*Connection, error) {\n  // ...\n}\n"))),(0,o.kt)("td",null,(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// package db\n\ntype Option interface {\n  // ...\n}\n\nfunc WithCache(c bool) Option {\n  // ...\n}\n\nfunc WithLogger(log *zap.Logger) Option {\n  // ...\n}\n\n// Open creates a connection.\nfunc Open(\n  addr string,\n  opts ...Option,\n) (*Connection, error) {\n  // ...\n}\n")))),(0,o.kt)("tr",null,(0,o.kt)("td",null,(0,o.kt)("p",null,"The cache and logger parameters must always be provided, even if the user\nwants to use the default."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"db.Open(addr, db.DefaultCache, zap.NewNop())\ndb.Open(addr, db.DefaultCache, log)\ndb.Open(addr, false /* cache */, zap.NewNop())\ndb.Open(addr, false /* cache */, log)\n"))),(0,o.kt)("td",null,(0,o.kt)("p",null,"Options are provided only if needed."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"db.Open(addr)\ndb.Open(addr, db.WithLogger(log))\ndb.Open(addr, db.WithCache(false))\ndb.Open(\n  addr,\n  db.WithCache(false),\n  db.WithLogger(log),\n)\n")))))),(0,o.kt)("p",null,"Our suggested way of implementing this pattern is with an ",(0,o.kt)("inlineCode",{parentName:"p"},"Option")," interface\nthat holds an unexported method, recording options on an unexported ",(0,o.kt)("inlineCode",{parentName:"p"},"options"),"\nstruct."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"type options struct {\n  cache  bool\n  logger *zap.Logger\n}\n\ntype Option interface {\n  apply(*options)\n}\n\ntype cacheOption bool\n\nfunc (c cacheOption) apply(opts *options) {\n  opts.cache = bool(c)\n}\n\nfunc WithCache(c bool) Option {\n  return cacheOption(c)\n}\n\ntype loggerOption struct {\n  Log *zap.Logger\n}\n\nfunc (l loggerOption) apply(opts *options) {\n  opts.logger = l.Log\n}\n\nfunc WithLogger(log *zap.Logger) Option {\n  return loggerOption{Log: log}\n}\n\n// Open creates a connection.\nfunc Open(\n  addr string,\n  opts ...Option,\n) (*Connection, error) {\n  options := options{\n    cache:  defaultCache,\n    logger: zap.NewNop(),\n  }\n\n  for _, o := range opts {\n    o.apply(&options)\n  }\n\n  // ...\n}\n")),(0,o.kt)("p",null,"Note that there's a method of implementing this pattern with closures but we\nbelieve that the pattern above provides more flexibility for authors and is\neasier to debug and test for users. In particular, it allows options to be\ncompared against each other in tests and mocks, versus closures where this is\nimpossible. Further, it lets options implement other interfaces, including\n",(0,o.kt)("inlineCode",{parentName:"p"},"fmt.Stringer")," which allows for user-readable string representations of the\noptions."),(0,o.kt)("p",null,"See also,"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html"},"Self-referential functions and the design of options"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis"},"Functional options for friendly APIs")))))}u.isMDXComponent=!0}}]);