"use strict";(globalThis.webpackChunkgo_faster_docs=globalThis.webpackChunkgo_faster_docs||[]).push([[300],{5680:(e,n,l)=>{l.d(n,{xA:()=>u,yg:()=>p});var t=l(6540);function a(e,n,l){return n in e?Object.defineProperty(e,n,{value:l,enumerable:!0,configurable:!0,writable:!0}):e[n]=l,e}function r(e,n){var l=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),l.push.apply(l,t)}return l}function i(e){for(var n=1;n<arguments.length;n++){var l=null!=arguments[n]?arguments[n]:{};n%2?r(Object(l),!0).forEach((function(n){a(e,n,l[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(l)):r(Object(l)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(l,n))}))}return e}function o(e,n){if(null==e)return{};var l,t,a=function(e,n){if(null==e)return{};var l,t,a={},r=Object.keys(e);for(t=0;t<r.length;t++)l=r[t],n.indexOf(l)>=0||(a[l]=e[l]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)l=r[t],n.indexOf(l)>=0||Object.prototype.propertyIsEnumerable.call(e,l)&&(a[l]=e[l])}return a}var g=t.createContext({}),s=function(e){var n=t.useContext(g),l=n;return e&&(l="function"==typeof e?e(n):i(i({},n),e)),l},u=function(e){var n=s(e.components);return t.createElement(g.Provider,{value:n},e.children)},y={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},d=t.forwardRef((function(e,n){var l=e.components,a=e.mdxType,r=e.originalType,g=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=s(l),p=a,c=d["".concat(g,".").concat(p)]||d[p]||y[p]||r;return l?t.createElement(c,i(i({ref:n},u),{},{components:l})):t.createElement(c,i({ref:n},u))}));function p(e,n){var l=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=l.length,i=new Array(r);i[0]=d;var o={};for(var g in n)hasOwnProperty.call(n,g)&&(o[g]=n[g]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var s=2;s<r;s++)i[s]=l[s];return t.createElement.apply(null,i)}return t.createElement.apply(null,l)}d.displayName="MDXCreateElement"},8992:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>g,contentTitle:()=>i,default:()=>y,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var t=l(8168),a=(l(6540),l(5680));const r={id:"style",title:"Style",sidebar_position:4},i=void 0,o={unversionedId:"style-guide/style",id:"style-guide/style",title:"Style",description:"Avoid overly long lines",source:"@site/docs/style-guide/style.mdx",sourceDirName:"style-guide",slug:"/style-guide/style",permalink:"/docs/style-guide/style",draft:!1,editUrl:"https://github.com/go-faster/web/edit/main/docs/style-guide/style.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"style",title:"Style",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Performance",permalink:"/docs/style-guide/performance"},next:{title:"Patterns",permalink:"/docs/style-guide/patterns"}},g={},s=[{value:"Avoid overly long lines",id:"avoid-overly-long-lines",level:2},{value:"Be Consistent",id:"be-consistent",level:2},{value:"Group Similar Declarations",id:"group-similar-declarations",level:2},{value:"Import Group Ordering",id:"import-group-ordering",level:2},{value:"Package Names",id:"package-names",level:2},{value:"Function Names",id:"function-names",level:2},{value:"Import Aliasing",id:"import-aliasing",level:2},{value:"Function Grouping and Ordering",id:"function-grouping-and-ordering",level:2},{value:"Reduce Nesting",id:"reduce-nesting",level:2},{value:"Unnecessary Else",id:"unnecessary-else",level:2},{value:"Top-level Variable Declarations",id:"top-level-variable-declarations",level:2},{value:"Prefix Unexported Globals with _",id:"prefix-unexported-globals-with-_",level:2},{value:"Embedding in Structs",id:"embedding-in-structs",level:2},{value:"Local Variable Declarations",id:"local-variable-declarations",level:2},{value:"nil is a valid slice",id:"nil-is-a-valid-slice",level:2},{value:"Reduce Scope of Variables",id:"reduce-scope-of-variables",level:2},{value:"Avoid Naked Parameters",id:"avoid-naked-parameters",level:2},{value:"Use Raw String Literals to Avoid Escaping",id:"use-raw-string-literals-to-avoid-escaping",level:2},{value:"Initializing Structs",id:"initializing-structs",level:2},{value:"Use Field Names to Initialize Structs",id:"use-field-names-to-initialize-structs",level:3},{value:"Omit Zero Value Fields in Structs",id:"omit-zero-value-fields-in-structs",level:3},{value:"Use <code>var</code> for Zero Value Structs",id:"use-var-for-zero-value-structs",level:3},{value:"Initializing Struct References",id:"initializing-struct-references",level:3},{value:"Initializing Maps",id:"initializing-maps",level:2},{value:"Format Strings outside Printf",id:"format-strings-outside-printf",level:2},{value:"Naming Printf-style Functions",id:"naming-printf-style-functions",level:2}],u={toc:s};function y(e){let{components:n,...l}=e;return(0,a.yg)("wrapper",(0,t.A)({},u,l,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h2",{id:"avoid-overly-long-lines"},"Avoid overly long lines"),(0,a.yg)("p",null,"Avoid lines of code that require readers to scroll horizontally\nor turn their heads too much."),(0,a.yg)("p",null,"We recommend a soft line length limit of ",(0,a.yg)("strong",{parentName:"p"},"99 characters"),".\nAuthors should aim to wrap lines before hitting this limit,\nbut it is not a hard limit.\nCode is allowed to exceed this limit."),(0,a.yg)("h2",{id:"be-consistent"},"Be Consistent"),(0,a.yg)("p",null,"Some of the guidelines outlined in this document can be evaluated objectively;\nothers are situational, contextual, or subjective."),(0,a.yg)("p",null,"Above all else, ",(0,a.yg)("strong",{parentName:"p"},"be consistent"),"."),(0,a.yg)("p",null,"Consistent code is easier to maintain, is easier to rationalize, requires less\ncognitive overhead, and is easier to migrate or update as new conventions emerge\nor classes of bugs are fixed."),(0,a.yg)("p",null,"Conversely, having multiple disparate or conflicting styles within a single\ncodebase causes maintenance overhead, uncertainty, and cognitive dissonance,\nall of which can directly contribute to lower velocity, painful code reviews,\nand bugs."),(0,a.yg)("p",null,"When applying these guidelines to a codebase, it is recommended that changes\nare made at a package (or larger) level: application at a sub-package level\nviolates the above concern by introducing multiple styles into the same code."),(0,a.yg)("h2",{id:"group-similar-declarations"},"Group Similar Declarations"),(0,a.yg)("p",null,"Go supports grouping similar declarations."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'import "a"\nimport "b"\n'))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'import (\n  "a"\n  "b"\n)\n')))))),(0,a.yg)("p",null,"This also applies to constants, variables, and type declarations."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"\nconst a = 1\nconst b = 2\n\n\n\nvar a = 1\nvar b = 2\n\n\n\ntype Area float64\ntype Volume float64\n"))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"const (\n  a = 1\n  b = 2\n)\n\nvar (\n  a = 1\n  b = 2\n)\n\ntype (\n  Area float64\n  Volume float64\n)\n")))))),(0,a.yg)("p",null,"Only group related declarations. Do not group declarations that are unrelated."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'type Operation int\n\nconst (\n  Add Operation = iota + 1\n  Subtract\n  Multiply\n  EnvVar = "MY_ENV"\n)\n'))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'type Operation int\n\nconst (\n  Add Operation = iota + 1\n  Subtract\n  Multiply\n)\n\nconst EnvVar = "MY_ENV"\n')))))),(0,a.yg)("p",null,"Groups are not limited in where they can be used. For example, you can use them\ninside of functions."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"func f() string {\n  var red = color.New(0xff0000)\n  var green = color.New(0x00ff00)\n  var blue = color.New(0x0000ff)\n\n  ...\n}\n"))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"func f() string {\n  var (\n    red   = color.New(0xff0000)\n    green = color.New(0x00ff00)\n    blue  = color.New(0x0000ff)\n  )\n\n  ...\n}\n")))))),(0,a.yg)("h2",{id:"import-group-ordering"},"Import Group Ordering"),(0,a.yg)("p",null,"There should be two import groups:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Standard library"),(0,a.yg)("li",{parentName:"ul"},"Everything else")),(0,a.yg)("p",null,"This is the grouping applied by goimports by default."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'import (\n  "fmt"\n  "os"\n  "go.uber.org/atomic"\n  "golang.org/x/sync/errgroup"\n)\n'))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'import (\n  "fmt"\n  "os"\n\n  "go.uber.org/atomic"\n  "golang.org/x/sync/errgroup"\n)\n')))))),(0,a.yg)("h2",{id:"package-names"},"Package Names"),(0,a.yg)("p",null,"When naming packages, choose a name that is:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"All lower-case. No capitals or underscores."),(0,a.yg)("li",{parentName:"ul"},"Does not need to be renamed using named imports at most call sites."),(0,a.yg)("li",{parentName:"ul"},"Short and succinct. Remember that the name is identified in full at every call\nsite."),(0,a.yg)("li",{parentName:"ul"},"Not plural. For example, ",(0,a.yg)("inlineCode",{parentName:"li"},"net/url"),", not ",(0,a.yg)("inlineCode",{parentName:"li"},"net/urls"),"."),(0,a.yg)("li",{parentName:"ul"},'Not "common", "util", "shared", or "lib". These are bad, uninformative names.')),(0,a.yg)("p",null,"See also ",(0,a.yg)("a",{parentName:"p",href:"https://blog.golang.org/package-names"},"Package Names")," and ",(0,a.yg)("a",{parentName:"p",href:"https://rakyll.org/style-packages/"},"Style guideline for Go packages"),"."),(0,a.yg)("h2",{id:"function-names"},"Function Names"),(0,a.yg)("p",null,"We follow the Go community's convention of using ",(0,a.yg)("a",{parentName:"p",href:"https://golang.org/doc/effective_go.html#mixed-caps"},"MixedCaps for function\nnames"),". An exception is made for test functions, which may contain underscores\nfor the purpose of grouping related test cases, e.g.,\n",(0,a.yg)("inlineCode",{parentName:"p"},"TestMyFunction_WhatIsBeingTested"),"."),(0,a.yg)("h2",{id:"import-aliasing"},"Import Aliasing"),(0,a.yg)("p",null,"Import aliasing must be used if the package name does not match the last\nelement of the import path."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'import (\n  "net/http"\n\n  client "example.com/client-go"\n  trace "example.com/trace/v2"\n)\n')),(0,a.yg)("p",null,"In all other scenarios, import aliases should be avoided unless there is a\ndirect conflict between imports."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'import (\n  "fmt"\n  "os"\n\n\n  nettrace "golang.net/x/trace"\n)\n'))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'import (\n  "fmt"\n  "os"\n  "runtime/trace"\n\n  nettrace "golang.net/x/trace"\n)\n')))))),(0,a.yg)("h2",{id:"function-grouping-and-ordering"},"Function Grouping and Ordering"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Functions should be sorted in rough call order."),(0,a.yg)("li",{parentName:"ul"},"Functions in a file should be grouped by receiver.")),(0,a.yg)("p",null,"Therefore, exported functions should appear first in a file, after\n",(0,a.yg)("inlineCode",{parentName:"p"},"struct"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"const"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"var")," definitions."),(0,a.yg)("p",null,"A ",(0,a.yg)("inlineCode",{parentName:"p"},"newXYZ()"),"/",(0,a.yg)("inlineCode",{parentName:"p"},"NewXYZ()")," may appear after the type is defined, but before the\nrest of the methods on the receiver."),(0,a.yg)("p",null,"Since functions are grouped by receiver, plain utility functions should appear\ntowards the end of the file."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"func (s *something) Cost() {\n  return calcCost(s.weights)\n}\n\ntype something struct{ ... }\n\nfunc calcCost(n []int) int {...}\n\nfunc (s *something) Stop() {...}\n\nfunc newSomething() *something {\n    return &something{}\n}\n"))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"type something struct{ ... }\n\nfunc newSomething() *something {\n    return &something{}\n}\n\nfunc (s *something) Cost() {\n  return calcCost(s.weights)\n}\n\nfunc (s *something) Stop() {...}\n\nfunc calcCost(n []int) int {...}\n")))))),(0,a.yg)("h2",{id:"reduce-nesting"},"Reduce Nesting"),(0,a.yg)("p",null,"Code should reduce nesting where possible by handling error cases/special\nconditions first and returning early or continuing the loop. Reduce the amount\nof code that is nested multiple levels."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'for _, v := range data {\n  if v.F1 == 1 {\n    v = process(v)\n    if err := v.Call(); err == nil {\n      v.Send()\n    } else {\n      return err\n    }\n  } else {\n    log.Printf("Invalid v: %v", v)\n  }\n}\n'))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'for _, v := range data {\n  if v.F1 != 1 {\n    log.Printf("Invalid v: %v", v)\n    continue\n  }\n\n  v = process(v)\n  if err := v.Call(); err != nil {\n    return err\n  }\n  v.Send()\n}\n')))))),(0,a.yg)("h2",{id:"unnecessary-else"},"Unnecessary Else"),(0,a.yg)("p",null,"If a variable is set in both branches of an if, it can be replaced with a\nsingle if."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"var a int\nif b {\n  a = 100\n} else {\n  a = 10\n}\n"))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"a := 10\nif b {\n  a = 100\n}\n")))))),(0,a.yg)("h2",{id:"top-level-variable-declarations"},"Top-level Variable Declarations"),(0,a.yg)("p",null,"At the top level, use the standard ",(0,a.yg)("inlineCode",{parentName:"p"},"var")," keyword. Do not specify the type,\nunless it is not the same type as the expression."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'var _s string = F()\n\nfunc F() string { return "A" }\n'))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'var _s = F()\n// Since F already states that it returns a string, we don\'t need to specify\n// the type again.\n\nfunc F() string { return "A" }\n')))))),(0,a.yg)("p",null,"Specify the type if the type of the expression does not match the desired type\nexactly."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'type myError struct{}\n\nfunc (myError) Error() string { return "error" }\n\nfunc F() myError { return myError{} }\n\nvar _e error = F()\n// F returns an object of type myError but we want error.\n')),(0,a.yg)("h2",{id:"prefix-unexported-globals-with-_"},"Prefix Unexported Globals with _"),(0,a.yg)("p",null,"Prefix unexported top-level ",(0,a.yg)("inlineCode",{parentName:"p"},"var"),"s and ",(0,a.yg)("inlineCode",{parentName:"p"},"const"),"s with ",(0,a.yg)("inlineCode",{parentName:"p"},"_")," to make it clear when\nthey are used that they are global symbols."),(0,a.yg)("p",null,"Exception: Unexported error values, which should be prefixed with ",(0,a.yg)("inlineCode",{parentName:"p"},"err"),"."),(0,a.yg)("p",null,"Rationale: Top-level variables and constants have a package scope. Using a\ngeneric name makes it easy to accidentally use the wrong value in a different\nfile."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'// foo.go\n\nconst (\n  defaultPort = 8080\n  defaultUser = "user"\n)\n\n// bar.go\n\nfunc Bar() {\n  defaultPort := 9090\n  ...\n  fmt.Println("Default port", defaultPort)\n\n  // We will not see a compile error if the first line of\n  // Bar() is deleted.\n}\n'))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'// foo.go\n\nconst (\n  _defaultPort = 8080\n  _defaultUser = "user"\n)\n')))))),(0,a.yg)("p",null,(0,a.yg)("strong",{parentName:"p"},"Exception"),": Unexported error values may use the prefix ",(0,a.yg)("inlineCode",{parentName:"p"},"err")," without the underscore.\nSee ",(0,a.yg)("a",{parentName:"p",href:"#error-naming"},"Error Naming"),"."),(0,a.yg)("h2",{id:"embedding-in-structs"},"Embedding in Structs"),(0,a.yg)("p",null,"Embedded types (such as mutexes) should be at the top of the field list of a\nstruct, and there must be an empty line separating embedded fields from regular\nfields."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"type Client struct {\n  version int\n  http.Client\n}\n"))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"type Client struct {\n  http.Client\n\n  version int\n}\n")))))),(0,a.yg)("p",null,"Embedding should provide tangible benefit, like adding or augmenting\nfunctionality in a semantically-appropriate way. It should do this with zero\nadverse user-facing effects (see also: ",(0,a.yg)("a",{parentName:"p",href:"#avoid-embedding-types-in-public-structs"},"Avoid Embedding Types in Public Structs"),")."),(0,a.yg)("p",null,"Embedding ",(0,a.yg)("strong",{parentName:"p"},"should not"),":"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Be purely cosmetic or convenience-oriented."),(0,a.yg)("li",{parentName:"ul"},"Make outer types more difficult to construct or use."),(0,a.yg)("li",{parentName:"ul"},"Affect outer types' zero values. If the outer type has a useful zero value, it\nshould still have a useful zero value after embedding the inner type."),(0,a.yg)("li",{parentName:"ul"},"Expose unrelated functions or fields from the outer type as a side-effect of\nembedding the inner type."),(0,a.yg)("li",{parentName:"ul"},"Expose unexported types."),(0,a.yg)("li",{parentName:"ul"},"Affect outer types' copy semantics."),(0,a.yg)("li",{parentName:"ul"},"Change the outer type's API or type semantics."),(0,a.yg)("li",{parentName:"ul"},"Embed a non-canonical form of the inner type."),(0,a.yg)("li",{parentName:"ul"},"Expose implementation details of the outer type."),(0,a.yg)("li",{parentName:"ul"},"Allow users to observe or control type internals."),(0,a.yg)("li",{parentName:"ul"},"Change the general behavior of inner functions through wrapping in a way that\nwould reasonably surprise users.")),(0,a.yg)("p",null,'Simply put, embed consciously and intentionally. A good litmus test is, "would\nall of these exported inner methods/fields be added directly to the outer type";\nif the answer is "some" or "no", don\'t embed the inner type - use a field\ninstead.'),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"type A struct {\n    // Bad: A.Lock() and A.Unlock() are\n    //      now available, provide no\n    //      functional benefit, and allow\n    //      users to control details about\n    //      the internals of A.\n    sync.Mutex\n}\n"))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"type countingWriteCloser struct {\n    // Good: Write() is provided at this\n    //       outer layer for a specific\n    //       purpose, and delegates work\n    //       to the inner type's Write().\n    io.WriteCloser\n\n    count int\n}\n\nfunc (w *countingWriteCloser) Write(bs []byte) (int, error) {\n    w.count += len(bs)\n    return w.WriteCloser.Write(bs)\n}\n")))),(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"type Book struct {\n    // Bad: pointer changes zero value usefulness\n    io.ReadWriter\n\n    // other fields\n}\n\n// later\n\nvar b Book\nb.Read(...)  // panic: nil pointer\nb.String()   // panic: nil pointer\nb.Write(...) // panic: nil pointer\n"))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"type Book struct {\n    // Good: has useful zero value\n    bytes.Buffer\n\n    // other fields\n}\n\n// later\n\nvar b Book\nb.Read(...)  // ok\nb.String()   // ok\nb.Write(...) // ok\n")))),(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"type Client struct {\n    sync.Mutex\n    sync.WaitGroup\n    bytes.Buffer\n    url.URL\n}\n"))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"type Client struct {\n    mtx sync.Mutex\n    wg  sync.WaitGroup\n    buf bytes.Buffer\n    url url.URL\n}\n")))))),(0,a.yg)("h2",{id:"local-variable-declarations"},"Local Variable Declarations"),(0,a.yg)("p",null,"Short variable declarations (",(0,a.yg)("inlineCode",{parentName:"p"},":="),") should be used if a variable is being set to\nsome value explicitly."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'var s = "foo"\n'))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'s := "foo"\n')))))),(0,a.yg)("p",null,"However, there are cases where the default value is clearer when the ",(0,a.yg)("inlineCode",{parentName:"p"},"var"),"\nkeyword is used. ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices"},"Declaring Empty Slices"),", for example."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"func f(list []int) {\n  filtered := []int{}\n  for _, v := range list {\n    if v > 10 {\n      filtered = append(filtered, v)\n    }\n  }\n}\n"))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"func f(list []int) {\n  var filtered []int\n  for _, v := range list {\n    if v > 10 {\n      filtered = append(filtered, v)\n    }\n  }\n}\n")))))),(0,a.yg)("h2",{id:"nil-is-a-valid-slice"},"nil is a valid slice"),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"nil")," is a valid slice of length 0. This means that,"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"You should not return a slice of length zero explicitly. Return ",(0,a.yg)("inlineCode",{parentName:"p"},"nil"),"\ninstead."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",{parentName:"li"},(0,a.yg)("code",{parentName:"pre",className:"language-go"},'if x == "" {\n  return []int{}\n}\n'))),(0,a.yg)("td",null,(0,a.yg)("pre",{parentName:"li"},(0,a.yg)("code",{parentName:"pre",className:"language-go"},'if x == "" {\n  return nil\n}\n'))))))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"To check if a slice is empty, always use ",(0,a.yg)("inlineCode",{parentName:"p"},"len(s) == 0"),". Do not check for\n",(0,a.yg)("inlineCode",{parentName:"p"},"nil"),"."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",{parentName:"li"},(0,a.yg)("code",{parentName:"pre",className:"language-go"},"func isEmpty(s []string) bool {\n  return s == nil\n}\n"))),(0,a.yg)("td",null,(0,a.yg)("pre",{parentName:"li"},(0,a.yg)("code",{parentName:"pre",className:"language-go"},"func isEmpty(s []string) bool {\n  return len(s) == 0\n}\n"))))))),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"The zero value (a slice declared with ",(0,a.yg)("inlineCode",{parentName:"p"},"var"),") is usable immediately without\n",(0,a.yg)("inlineCode",{parentName:"p"},"make()"),"."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",{parentName:"li"},(0,a.yg)("code",{parentName:"pre",className:"language-go"},"nums := []int{}\n// or, nums := make([]int)\n\nif add1 {\n  nums = append(nums, 1)\n}\n\nif add2 {\n  nums = append(nums, 2)\n}\n"))),(0,a.yg)("td",null,(0,a.yg)("pre",{parentName:"li"},(0,a.yg)("code",{parentName:"pre",className:"language-go"},"var nums []int\n\nif add1 {\n  nums = append(nums, 1)\n}\n\nif add2 {\n  nums = append(nums, 2)\n}\n")))))))),(0,a.yg)("p",null,"Remember that, while it is a valid slice, a nil slice is not equivalent to an\nallocated slice of length 0 - one is nil and the other is not - and the two may\nbe treated differently in different situations (such as serialization)."),(0,a.yg)("h2",{id:"reduce-scope-of-variables"},"Reduce Scope of Variables"),(0,a.yg)("p",null,"Where possible, reduce scope of variables. Do not reduce the scope if it\nconflicts with ",(0,a.yg)("a",{parentName:"p",href:"#reduce-nesting"},"Reduce Nesting"),"."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"err := ioutil.WriteFile(name, data, 0644)\nif err != nil {\n return err\n}\n"))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"if err := ioutil.WriteFile(name, data, 0644); err != nil {\n return err\n}\n")))))),(0,a.yg)("p",null,"If you need a result of a function call outside of the if, then you should not\ntry to reduce the scope."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"if data, err := ioutil.ReadFile(name); err == nil {\n  err = cfg.Decode(data)\n  if err != nil {\n    return err\n  }\n\n  fmt.Println(cfg)\n  return nil\n} else {\n  return err\n}\n"))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"data, err := ioutil.ReadFile(name)\nif err != nil {\n   return err\n}\n\nif err := cfg.Decode(data); err != nil {\n  return err\n}\n\nfmt.Println(cfg)\nreturn nil\n")))))),(0,a.yg)("h2",{id:"avoid-naked-parameters"},"Avoid Naked Parameters"),(0,a.yg)("p",null,"Naked parameters in function calls can hurt readability. Add C-style comments\n(",(0,a.yg)("inlineCode",{parentName:"p"},"/* ... */"),") for parameter names when their meaning is not obvious."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'// func printInfo(name string, isLocal, done bool)\n\nprintInfo("foo", true, true)\n'))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'// func printInfo(name string, isLocal, done bool)\n\nprintInfo("foo", true /* isLocal */, true /* done */)\n')))))),(0,a.yg)("p",null,"Better yet, replace naked ",(0,a.yg)("inlineCode",{parentName:"p"},"bool")," types with custom types for more readable and\ntype-safe code. This allows more than just two states (true/false) for that\nparameter in the future."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"type Region int\n\nconst (\n  UnknownRegion Region = iota\n  Local\n)\n\ntype Status int\n\nconst (\n  StatusReady Status = iota + 1\n  StatusDone\n  // Maybe we will have a StatusInProgress in the future.\n)\n\nfunc printInfo(name string, region Region, status Status)\n")),(0,a.yg)("h2",{id:"use-raw-string-literals-to-avoid-escaping"},"Use Raw String Literals to Avoid Escaping"),(0,a.yg)("p",null,"Go supports ",(0,a.yg)("a",{parentName:"p",href:"https://golang.org/ref/spec#raw_string_lit"},"raw string literals"),",\nwhich can span multiple lines and include quotes. Use these to avoid\nhand-escaped strings which are much harder to read."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'wantError := "unknown name:\\"test\\""\n'))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'wantError := `unknown error:"test"`\n')))))),(0,a.yg)("h2",{id:"initializing-structs"},"Initializing Structs"),(0,a.yg)("h3",{id:"use-field-names-to-initialize-structs"},"Use Field Names to Initialize Structs"),(0,a.yg)("p",null,"You should almost always specify field names when initializing structs. This is\nnow enforced by ",(0,a.yg)("a",{parentName:"p",href:"https://golang.org/cmd/vet/"},(0,a.yg)("inlineCode",{parentName:"a"},"go vet")),"."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'k := User{"John", "Doe", true}\n'))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'k := User{\n    FirstName: "John",\n    LastName: "Doe",\n    Admin: true,\n}\n')))))),(0,a.yg)("p",null,"Exception: Field names ",(0,a.yg)("em",{parentName:"p"},"may")," be omitted in test tables when there are 3 or\nfewer fields."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'tests := []struct{\n  op Operation\n  want string\n}{\n  {Add, "add"},\n  {Subtract, "subtract"},\n}\n')),(0,a.yg)("h3",{id:"omit-zero-value-fields-in-structs"},"Omit Zero Value Fields in Structs"),(0,a.yg)("p",null,"When initializing structs with field names, omit fields that have zero values\nunless they provide meaningful context. Otherwise, let Go set these to zero\nvalues automatically."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'user := User{\n  FirstName: "John",\n  LastName: "Doe",\n  MiddleName: "",\n  Admin: false,\n}\n'))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'user := User{\n  FirstName: "John",\n  LastName: "Doe",\n}\n')))))),(0,a.yg)("p",null,"This helps reduce noise for readers by omitting values that are default in\nthat context. Only meaningful values are specified."),(0,a.yg)("p",null,"Include zero values where field names provide meaningful context. For example,\ntest cases in ",(0,a.yg)("a",{parentName:"p",href:"#test-tables"},"Test Tables")," can benefit from names of fields\neven when they are zero-valued."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'tests := []struct{\n  give string\n  want int\n}{\n  {give: "0", want: 0},\n  // ...\n}\n')),(0,a.yg)("h3",{id:"use-var-for-zero-value-structs"},"Use ",(0,a.yg)("inlineCode",{parentName:"h3"},"var")," for Zero Value Structs"),(0,a.yg)("p",null,"When all the fields of a struct are omitted in a declaration, use the ",(0,a.yg)("inlineCode",{parentName:"p"},"var"),"\nform to declare the struct."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"user := User{}\n"))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"var user User\n")))))),(0,a.yg)("p",null,"This differentiates zero valued structs from those with non-zero fields\nsimilar to the distinction created for ",(0,a.yg)("a",{parentName:"p",href:"#initializing-maps"},"map initialization"),", and matches how\nwe prefer to ",(0,a.yg)("a",{parentName:"p",href:"https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices"},"declare empty slices"),"."),(0,a.yg)("h3",{id:"initializing-struct-references"},"Initializing Struct References"),(0,a.yg)("p",null,"Use ",(0,a.yg)("inlineCode",{parentName:"p"},"&T{}")," instead of ",(0,a.yg)("inlineCode",{parentName:"p"},"new(T)")," when initializing struct references so that it\nis consistent with the struct initialization."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'sval := T{Name: "foo"}\n\n// inconsistent\nsptr := new(T)\nsptr.Name = "bar"\n'))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'sval := T{Name: "foo"}\n\nsptr := &T{Name: "bar"}\n')))))),(0,a.yg)("h2",{id:"initializing-maps"},"Initializing Maps"),(0,a.yg)("p",null,"Prefer ",(0,a.yg)("inlineCode",{parentName:"p"},"make(..)")," for empty maps, and maps populated\nprogrammatically. This makes map initialization visually\ndistinct from declaration, and it makes it easy to add size\nhints later if available."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"var (\n  // m1 is safe to read and write;\n  // m2 will panic on writes.\n  m1 = map[T1]T2{}\n  m2 map[T1]T2\n)\n"))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"var (\n  // m1 is safe to read and write;\n  // m2 will panic on writes.\n  m1 = make(map[T1]T2)\n  m2 map[T1]T2\n)\n")))),(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("p",null,"Declaration and initialization are visually similar.")),(0,a.yg)("td",null,(0,a.yg)("p",null,"Declaration and initialization are visually distinct."))))),(0,a.yg)("p",null,"Where possible, provide capacity hints when initializing\nmaps with ",(0,a.yg)("inlineCode",{parentName:"p"},"make()"),". See\n",(0,a.yg)("a",{parentName:"p",href:"#specifying-map-capacity-hints"},"Specifying Map Capacity Hints"),"\nfor more information."),(0,a.yg)("p",null,"On the other hand, if the map holds a fixed list of elements,\nuse map literals to initialize the map."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"m := make(map[T1]T2, 3)\nm[k1] = v1\nm[k2] = v2\nm[k3] = v3\n"))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},"m := map[T1]T2{\n  k1: v1,\n  k2: v2,\n  k3: v3,\n}\n")))))),(0,a.yg)("p",null,"The basic rule of thumb is to use map literals when adding a fixed set of\nelements at initialization time, otherwise use ",(0,a.yg)("inlineCode",{parentName:"p"},"make")," (and specify a size hint\nif available)."),(0,a.yg)("h2",{id:"format-strings-outside-printf"},"Format Strings outside Printf"),(0,a.yg)("p",null,"If you declare format strings for ",(0,a.yg)("inlineCode",{parentName:"p"},"Printf"),"-style functions outside a string\nliteral, make them ",(0,a.yg)("inlineCode",{parentName:"p"},"const")," values."),(0,a.yg)("p",null,"This helps ",(0,a.yg)("inlineCode",{parentName:"p"},"go vet")," perform static analysis of the format string."),(0,a.yg)("table",null,(0,a.yg)("thead",null,(0,a.yg)("tr",null,(0,a.yg)("th",null,"Bad"),(0,a.yg)("th",null,"Good"))),(0,a.yg)("tbody",null,(0,a.yg)("tr",null,(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'msg := "unexpected values %v, %v\\n"\nfmt.Printf(msg, 1, 2)\n'))),(0,a.yg)("td",null,(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-go"},'const msg = "unexpected values %v, %v\\n"\nfmt.Printf(msg, 1, 2)\n')))))),(0,a.yg)("h2",{id:"naming-printf-style-functions"},"Naming Printf-style Functions"),(0,a.yg)("p",null,"When you declare a ",(0,a.yg)("inlineCode",{parentName:"p"},"Printf"),"-style function, make sure that ",(0,a.yg)("inlineCode",{parentName:"p"},"go vet")," can detect\nit and check the format string."),(0,a.yg)("p",null,"This means that you should use predefined ",(0,a.yg)("inlineCode",{parentName:"p"},"Printf"),"-style function\nnames if possible. ",(0,a.yg)("inlineCode",{parentName:"p"},"go vet")," will check these by default. See ",(0,a.yg)("a",{parentName:"p",href:"https://golang.org/cmd/vet/#hdr-Printf_family"},"Printf family"),"\nfor more information."),(0,a.yg)("p",null,"If using the predefined names is not an option, end the name you choose with\nf: ",(0,a.yg)("inlineCode",{parentName:"p"},"Wrapf"),", not ",(0,a.yg)("inlineCode",{parentName:"p"},"Wrap"),". ",(0,a.yg)("inlineCode",{parentName:"p"},"go vet")," can be asked to check specific ",(0,a.yg)("inlineCode",{parentName:"p"},"Printf"),"-style\nnames but they must end with f."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-shell"},"$ go vet -printfuncs=wrapf,statusf\n")),(0,a.yg)("p",null,"See also ",(0,a.yg)("a",{parentName:"p",href:"https://kuzminva.wordpress.com/2017/11/07/go-vet-printf-family-check/"},"go vet: Printf family check"),"."))}y.isMDXComponent=!0}}]);