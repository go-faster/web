"use strict";(globalThis.webpackChunkgo_faster_docs=globalThis.webpackChunkgo_faster_docs||[]).push([[736],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>c});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=u(n),c=r,k=m["".concat(s,".").concat(c)]||m[c]||d[c]||l;return n?a.createElement(k,o(o({ref:t},p),{},{components:n})):a.createElement(k,o({ref:t},p))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var u=2;u<l;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9238:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const l={id:"guidelines",title:"Guidelines",sidebar_position:2},o=void 0,i={unversionedId:"style-guide/guidelines",id:"style-guide/guidelines",title:"Guidelines",description:"Pointers to Interfaces",source:"@site/docs/style-guide/guidelines.mdx",sourceDirName:"style-guide",slug:"/style-guide/guidelines",permalink:"/docs/style-guide/guidelines",editUrl:"https://github.com/go-faster/web/edit/main/docs/style-guide/guidelines.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"guidelines",title:"Guidelines",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/docs/style-guide"},next:{title:"Performance",permalink:"/docs/style-guide/performance"}},s={},u=[{value:"Pointers to Interfaces",id:"pointers-to-interfaces",level:2},{value:"Verify Interface Compliance",id:"verify-interface-compliance",level:2},{value:"Receivers and Interfaces",id:"receivers-and-interfaces",level:2},{value:"Zero-value Mutexes are Valid",id:"zero-value-mutexes-are-valid",level:2},{value:"Copy Slices and Maps at Boundaries",id:"copy-slices-and-maps-at-boundaries",level:2},{value:"Receiving Slices and Maps",id:"receiving-slices-and-maps",level:3},{value:"Returning Slices and Maps",id:"returning-slices-and-maps",level:3},{value:"Defer to Clean Up",id:"defer-to-clean-up",level:2},{value:"Channel Size is One or None",id:"channel-size-is-one-or-none",level:2},{value:"Start Enums at One",id:"start-enums-at-one",level:2},{value:"Use <code>&quot;time&quot;</code> to handle time",id:"use-time-to-handle-time",level:2},{value:"Use <code>time.Time</code> for instants of time",id:"use-timetime-for-instants-of-time",level:3},{value:"Use <code>time.Duration</code> for periods of time",id:"use-timeduration-for-periods-of-time",level:3},{value:"Use <code>time.Time</code> and <code>time.Duration</code> with external systems",id:"use-timetime-and-timeduration-with-external-systems",level:3},{value:"Errors",id:"errors",level:2},{value:"Error Types",id:"error-types",level:3},{value:"Error Wrapping",id:"error-wrapping",level:3},{value:"Error Naming",id:"error-naming",level:3},{value:"Handle Type Assertion Failures",id:"handle-type-assertion-failures",level:2},{value:"Don&#39;t Panic",id:"dont-panic",level:2},{value:"Use go.uber.org/atomic",id:"use-gouberorgatomic",level:2},{value:"Avoid Mutable Globals",id:"avoid-mutable-globals",level:2},{value:"Avoid Embedding Types in Public Structs",id:"avoid-embedding-types-in-public-structs",level:2},{value:"Avoid Using Built-In Names",id:"avoid-using-built-in-names",level:2},{value:"Avoid <code>init()</code>",id:"avoid-init",level:2},{value:"Exit in Main",id:"exit-in-main",level:2},{value:"Exit Once",id:"exit-once",level:3}],p={toc:u};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"pointers-to-interfaces"},"Pointers to Interfaces"),(0,r.kt)("p",null,"You almost never need a pointer to an interface. You should be passing\ninterfaces as values\u2014the underlying data can still be a pointer."),(0,r.kt)("p",null,"An interface is two fields:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},'A pointer to some type-specific information. You can think of this as\n"type."'),(0,r.kt)("li",{parentName:"ol"},"Data pointer. If the data stored is a pointer, it\u2019s stored directly. If\nthe data stored is a value, then a pointer to the value is stored.")),(0,r.kt)("p",null,"If you want interface methods to modify the underlying data, you must use a\npointer."),(0,r.kt)("h2",{id:"verify-interface-compliance"},"Verify Interface Compliance"),(0,r.kt)("p",null,"Verify interface compliance at compile time where appropriate. This includes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Exported types that are required to implement specific interfaces as part of\ntheir API contract"),(0,r.kt)("li",{parentName:"ul"},"Exported or unexported types that are part of a collection of types\nimplementing the same interface"),(0,r.kt)("li",{parentName:"ul"},"Other cases where violating an interface would break users")),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type Handler struct {\n  // ...\n}\n\n\n\nfunc (h *Handler) ServeHTTP(\n  w http.ResponseWriter,\n  r *http.Request,\n) {\n  ...\n}\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type Handler struct {\n  // ...\n}\n\nvar _ http.Handler = (*Handler)(nil)\n\nfunc (h *Handler) ServeHTTP(\n  w http.ResponseWriter,\n  r *http.Request,\n) {\n  // ...\n}\n")))))),(0,r.kt)("p",null,"The statement ",(0,r.kt)("inlineCode",{parentName:"p"},"var _ http.Handler = (*Handler)(nil)")," will fail to compile if\n",(0,r.kt)("inlineCode",{parentName:"p"},"*Handler")," ever stops matching the ",(0,r.kt)("inlineCode",{parentName:"p"},"http.Handler")," interface."),(0,r.kt)("p",null,"The right hand side of the assignment should be the zero value of the asserted\ntype. This is ",(0,r.kt)("inlineCode",{parentName:"p"},"nil")," for pointer types (like ",(0,r.kt)("inlineCode",{parentName:"p"},"*Handler"),"), slices, and maps, and\nan empty struct for struct types."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type LogHandler struct {\n  h   http.Handler\n  log *zap.Logger\n}\n\nvar _ http.Handler = LogHandler{}\n\nfunc (h LogHandler) ServeHTTP(\n  w http.ResponseWriter,\n  r *http.Request,\n) {\n  // ...\n}\n")),(0,r.kt)("h2",{id:"receivers-and-interfaces"},"Receivers and Interfaces"),(0,r.kt)("p",null,"Methods with value receivers can be called on pointers as well as values.\nMethods with pointer receivers can only be called on pointers or ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/ref/spec#Method_values"},"addressable values"),"."),(0,r.kt)("p",null,"For example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'type S struct {\n  data string\n}\n\nfunc (s S) Read() string {\n  return s.data\n}\n\nfunc (s *S) Write(str string) {\n  s.data = str\n}\n\nsVals := map[int]S{1: {"A"}}\n\n// You can only call Read using a value\nsVals[1].Read()\n\n// This will not compile:\n//  sVals[1].Write("test")\n\nsPtrs := map[int]*S{1: {"A"}}\n\n// You can call both Read and Write using a pointer\nsPtrs[1].Read()\nsPtrs[1].Write("test")\n')),(0,r.kt)("p",null,"Similarly, an interface can be satisfied by a pointer, even if the method has a\nvalue receiver."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type F interface {\n  f()\n}\n\ntype S1 struct{}\n\nfunc (s S1) f() {}\n\ntype S2 struct{}\n\nfunc (s *S2) f() {}\n\ns1Val := S1{}\ns1Ptr := &S1{}\ns2Val := S2{}\ns2Ptr := &S2{}\n\nvar i F\ni = s1Val\ni = s1Ptr\ni = s2Ptr\n\n// The following doesn't compile, since s2Val is a value, and there is no value receiver for f.\n//   i = s2Val\n")),(0,r.kt)("p",null,"Effective Go has a good write up on ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/doc/effective_go.html#pointers_vs_values"},"Pointers vs. Values"),"."),(0,r.kt)("h2",{id:"zero-value-mutexes-are-valid"},"Zero-value Mutexes are Valid"),(0,r.kt)("p",null,"The zero-value of ",(0,r.kt)("inlineCode",{parentName:"p"},"sync.Mutex")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"sync.RWMutex")," is valid, so you almost\nnever need a pointer to a mutex."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"mu := new(sync.Mutex)\nmu.Lock()\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"var mu sync.Mutex\nmu.Lock()\n")))))),(0,r.kt)("p",null,"If you use a struct by pointer, then the mutex should be a non-pointer field on\nit. Do not embed the mutex on the struct, even if the struct is not exported."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type SMap struct {\n  sync.Mutex\n\n  data map[string]string\n}\n\nfunc NewSMap() *SMap {\n  return &SMap{\n    data: make(map[string]string),\n  }\n}\n\nfunc (m *SMap) Get(k string) string {\n  m.Lock()\n  defer m.Unlock()\n\n  return m.data[k]\n}\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type SMap struct {\n  mu sync.Mutex\n\n  data map[string]string\n}\n\nfunc NewSMap() *SMap {\n  return &SMap{\n    data: make(map[string]string),\n  }\n}\n\nfunc (m *SMap) Get(k string) string {\n  m.mu.Lock()\n  defer m.mu.Unlock()\n\n  return m.data[k]\n}\n")))),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Mutex")," field, and the ",(0,r.kt)("inlineCode",{parentName:"p"},"Lock")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Unlock")," methods are unintentionally part\nof the exported API of ",(0,r.kt)("inlineCode",{parentName:"p"},"SMap"),".")),(0,r.kt)("td",null,(0,r.kt)("p",null,"The mutex and its methods are implementation details of ",(0,r.kt)("inlineCode",{parentName:"p"},"SMap")," hidden from its\ncallers."))))),(0,r.kt)("h2",{id:"copy-slices-and-maps-at-boundaries"},"Copy Slices and Maps at Boundaries"),(0,r.kt)("p",null,"Slices and maps contain pointers to the underlying data so be wary of scenarios\nwhen they need to be copied."),(0,r.kt)("h3",{id:"receiving-slices-and-maps"},"Receiving Slices and Maps"),(0,r.kt)("p",null,"Keep in mind that users can modify a map or slice you received as an argument\nif you store a reference to it."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad")," ",(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func (d *Driver) SetTrips(trips []Trip) {\n  d.trips = trips\n}\n\ntrips := ...\nd1.SetTrips(trips)\n\n// Did you mean to modify d1.trips?\ntrips[0] = ...\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func (d *Driver) SetTrips(trips []Trip) {\n  d.trips = make([]Trip, len(trips))\n  copy(d.trips, trips)\n}\n\ntrips := ...\nd1.SetTrips(trips)\n\n// We can now modify trips[0] without affecting d1.trips.\ntrips[0] = ...\n")))))),(0,r.kt)("h3",{id:"returning-slices-and-maps"},"Returning Slices and Maps"),(0,r.kt)("p",null,"Similarly, be wary of user modifications to maps or slices exposing internal\nstate."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type Stats struct {\n  mu sync.Mutex\n  counters map[string]int\n}\n\n// Snapshot returns the current stats.\nfunc (s *Stats) Snapshot() map[string]int {\n  s.mu.Lock()\n  defer s.mu.Unlock()\n\n  return s.counters\n}\n\n// snapshot is no longer protected by the mutex, so any\n// access to the snapshot is subject to data races.\nsnapshot := stats.Snapshot()\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type Stats struct {\n  mu sync.Mutex\n  counters map[string]int\n}\n\nfunc (s *Stats) Snapshot() map[string]int {\n  s.mu.Lock()\n  defer s.mu.Unlock()\n\n  result := make(map[string]int, len(s.counters))\n  for k, v := range s.counters {\n    result[k] = v\n  }\n  return result\n}\n\n// Snapshot is now a copy.\nsnapshot := stats.Snapshot()\n")))))),(0,r.kt)("h2",{id:"defer-to-clean-up"},"Defer to Clean Up"),(0,r.kt)("p",null,"Use defer to clean up resources such as files and locks."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"p.Lock()\nif p.count < 10 {\n  p.Unlock()\n  return p.count\n}\n\np.count++\nnewCount := p.count\np.Unlock()\n\nreturn newCount\n\n// easy to miss unlocks due to multiple returns\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"p.Lock()\ndefer p.Unlock()\n\nif p.count < 10 {\n  return p.count\n}\n\np.count++\nreturn p.count\n\n// more readable\n")))))),(0,r.kt)("p",null,"Defer has an extremely small overhead and should be avoided only if you can\nprove that your function execution time is in the order of nanoseconds. The\nreadability win of using defers is worth the miniscule cost of using them. This\nis especially true for larger methods that have more than simple memory\naccesses, where the other computations are more significant than the ",(0,r.kt)("inlineCode",{parentName:"p"},"defer"),"."),(0,r.kt)("h2",{id:"channel-size-is-one-or-none"},"Channel Size is One or None"),(0,r.kt)("p",null,"Channels should usually have a size of one or be unbuffered. By default,\nchannels are unbuffered and have a size of zero. Any other size\nmust be subject to a high level of scrutiny. Consider how the size is\ndetermined, what prevents the channel from filling up under load and blocking\nwriters, and what happens when this occurs."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// Ought to be enough for anybody!\nc := make(chan int, 64)\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// Size of one\nc := make(chan int, 1) // or\n// Unbuffered channel, size of zero\nc := make(chan int)\n")))))),(0,r.kt)("h2",{id:"start-enums-at-one"},"Start Enums at One"),(0,r.kt)("p",null,"The standard way of introducing enumerations in Go is to declare a custom type\nand a ",(0,r.kt)("inlineCode",{parentName:"p"},"const")," group with ",(0,r.kt)("inlineCode",{parentName:"p"},"iota"),". Since variables have a 0 default value, you\nshould usually start your enums on a non-zero value."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type Operation int\n\nconst (\n  Add Operation = iota\n  Subtract\n  Multiply\n)\n\n// Add=0, Subtract=1, Multiply=2\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type Operation int\n\nconst (\n  Add Operation = iota + 1\n  Subtract\n  Multiply\n)\n\n// Add=1, Subtract=2, Multiply=3\n")))))),(0,r.kt)("p",null,"There are cases where using the zero value makes sense, for example when the\nzero value case is the desirable default behavior."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type LogOutput int\n\nconst (\n  LogToStdout LogOutput = iota\n  LogToFile\n  LogToRemote\n)\n\n// LogToStdout=0, LogToFile=1, LogToRemote=2\n")),(0,r.kt)("h2",{id:"use-time-to-handle-time"},"Use ",(0,r.kt)("inlineCode",{parentName:"h2"},'"time"')," to handle time"),(0,r.kt)("p",null,"Time is complicated. Incorrect assumptions often made about time include the\nfollowing."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A day has 24 hours"),(0,r.kt)("li",{parentName:"ol"},"An hour has 60 minutes"),(0,r.kt)("li",{parentName:"ol"},"A week has 7 days"),(0,r.kt)("li",{parentName:"ol"},"A year has 365 days"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time"},"And a lot more"))),(0,r.kt)("p",null,"For example, ",(0,r.kt)("em",{parentName:"p"},"1")," means that adding 24 hours to a time instant will not always\nyield a new calendar day."),(0,r.kt)("p",null,"Therefore, always use the ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/pkg/time/"},(0,r.kt)("inlineCode",{parentName:"a"},'"time"'))," package when dealing with time because it\nhelps deal with these incorrect assumptions in a safer, more accurate manner."),(0,r.kt)("h3",{id:"use-timetime-for-instants-of-time"},"Use ",(0,r.kt)("inlineCode",{parentName:"h3"},"time.Time")," for instants of time"),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/pkg/time/#Time"},(0,r.kt)("inlineCode",{parentName:"a"},"time.Time"))," when dealing with instants of time, and the methods on\n",(0,r.kt)("inlineCode",{parentName:"p"},"time.Time")," when comparing, adding, or subtracting time."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func isActive(now, start, stop int) bool {\n  return start <= now && now < stop\n}\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func isActive(now, start, stop time.Time) bool {\n  return (start.Before(now) || start.Equal(now)) && now.Before(stop)\n}\n")))))),(0,r.kt)("h3",{id:"use-timeduration-for-periods-of-time"},"Use ",(0,r.kt)("inlineCode",{parentName:"h3"},"time.Duration")," for periods of time"),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/pkg/time/#Duration"},(0,r.kt)("inlineCode",{parentName:"a"},"time.Duration"))," when dealing with periods of time."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func poll(delay int) {\n  for {\n    // ...\n    time.Sleep(time.Duration(delay) * time.Millisecond)\n  }\n}\n\npoll(10) // was it seconds or milliseconds?\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func poll(delay time.Duration) {\n  for {\n    // ...\n    time.Sleep(delay)\n  }\n}\n\npoll(10*time.Second)\n")))))),(0,r.kt)("p",null,"Going back to the example of adding 24 hours to a time instant, the method we\nuse to add time depends on intent. If we want the same time of the day, but on\nthe next calendar day, we should use ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/pkg/time/#Time.AddDate"},(0,r.kt)("inlineCode",{parentName:"a"},"Time.AddDate")),". However, if we want an\ninstant of time guaranteed to be 24 hours after the previous time, we should\nuse ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/pkg/time/#Time.Add"},(0,r.kt)("inlineCode",{parentName:"a"},"Time.Add")),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"newDay := t.AddDate(0 /* years */, 0 /* months */, 1 /* days */)\nmaybeNewDay := t.Add(24 * time.Hour)\n")),(0,r.kt)("h3",{id:"use-timetime-and-timeduration-with-external-systems"},"Use ",(0,r.kt)("inlineCode",{parentName:"h3"},"time.Time")," and ",(0,r.kt)("inlineCode",{parentName:"h3"},"time.Duration")," with external systems"),(0,r.kt)("p",null,"Use ",(0,r.kt)("inlineCode",{parentName:"p"},"time.Duration")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"time.Time")," in interactions with external systems when\npossible. For example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Command-line flags: ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/pkg/flag/"},(0,r.kt)("inlineCode",{parentName:"a"},"flag"))," supports ",(0,r.kt)("inlineCode",{parentName:"p"},"time.Duration")," via\n",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/pkg/time/#ParseDuration"},(0,r.kt)("inlineCode",{parentName:"a"},"time.ParseDuration")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"JSON: ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/pkg/encoding/json/"},(0,r.kt)("inlineCode",{parentName:"a"},"encoding/json"))," supports encoding ",(0,r.kt)("inlineCode",{parentName:"p"},"time.Time")," as an ",(0,r.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc3339"},"RFC 3339"),"\nstring via its ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/pkg/time/#Time.UnmarshalJSON"},(0,r.kt)("inlineCode",{parentName:"a"},"UnmarshalJSON")," method"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"SQL: ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/pkg/database/sql/"},(0,r.kt)("inlineCode",{parentName:"a"},"database/sql"))," supports converting ",(0,r.kt)("inlineCode",{parentName:"p"},"DATETIME")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"TIMESTAMP")," columns\ninto ",(0,r.kt)("inlineCode",{parentName:"p"},"time.Time")," and back if the underlying driver supports it")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"YAML: ",(0,r.kt)("a",{parentName:"p",href:"https://godoc.org/gopkg.in/yaml.v2"},(0,r.kt)("inlineCode",{parentName:"a"},"gopkg.in/yaml.v2"))," supports ",(0,r.kt)("inlineCode",{parentName:"p"},"time.Time")," as an ",(0,r.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc3339"},"RFC 3339")," string, and\n",(0,r.kt)("inlineCode",{parentName:"p"},"time.Duration")," via ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/pkg/time/#ParseDuration"},(0,r.kt)("inlineCode",{parentName:"a"},"time.ParseDuration")),"."))),(0,r.kt)("p",null,"When it is not possible to use ",(0,r.kt)("inlineCode",{parentName:"p"},"time.Duration")," in these interactions, use\n",(0,r.kt)("inlineCode",{parentName:"p"},"int")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"float64")," and include the unit in the name of the field."),(0,r.kt)("p",null,"For example, since ",(0,r.kt)("inlineCode",{parentName:"p"},"encoding/json")," does not support ",(0,r.kt)("inlineCode",{parentName:"p"},"time.Duration"),", the unit\nis included in the name of the field."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'// {"interval": 2}\ntype Config struct {\n  Interval int `json:"interval"`\n}\n'))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'// {"intervalMillis": 2000}\ntype Config struct {\n  IntervalMillis int `json:"intervalMillis"`\n}\n')))))),(0,r.kt)("p",null,"When it is not possible to use ",(0,r.kt)("inlineCode",{parentName:"p"},"time.Time")," in these interactions, unless an\nalternative is agreed upon, use ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," and format timestamps as defined in\n",(0,r.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc3339"},"RFC 3339"),". This format is used by default by ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/pkg/time/#Time.UnmarshalText"},(0,r.kt)("inlineCode",{parentName:"a"},"Time.UnmarshalText"))," and is\navailable for use in ",(0,r.kt)("inlineCode",{parentName:"p"},"Time.Format")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"time.Parse")," via ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/pkg/time/#RFC3339"},(0,r.kt)("inlineCode",{parentName:"a"},"time.RFC3339")),"."),(0,r.kt)("p",null,"Although this tends to not be a problem in practice, keep in mind that the\n",(0,r.kt)("inlineCode",{parentName:"p"},'"time"')," package does not support parsing timestamps with leap seconds\n(",(0,r.kt)("a",{parentName:"p",href:"https://github.com/golang/go/issues/8728"},"8728"),"), nor does it account for leap seconds in calculations (",(0,r.kt)("a",{parentName:"p",href:"https://github.com/golang/go/issues/15190"},"15190"),"). If\nyou compare two instants of time, the difference will not include the leap\nseconds that may have occurred between those two instants."),(0,r.kt)("h2",{id:"errors"},"Errors"),(0,r.kt)("p",null,"Use ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/go-faster/errors"},"github.com/go-faster/errors")," package instead of\n",(0,r.kt)("inlineCode",{parentName:"p"},"errors")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"fmt.Errorf"),"."),(0,r.kt)("h3",{id:"error-types"},"Error Types"),(0,r.kt)("p",null,"There are few options for declaring errors.\nConsider the following before picking the option best suited for your use case."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Does the caller need to match the error so that they can handle it?\nIf yes, we must support the ",(0,r.kt)("a",{parentName:"li",href:"https://pkg.go.dev/github.com/go-faster/errors#Is"},(0,r.kt)("inlineCode",{parentName:"a"},"errors.Is"))," or ",(0,r.kt)("a",{parentName:"li",href:"https://pkg.go.dev/github.com/go-faster/errors#As"},(0,r.kt)("inlineCode",{parentName:"a"},"errors.As"))," functions\nby declaring a top-level error variable or a custom type."),(0,r.kt)("li",{parentName:"ul"},"Is the error message a static string,\nor is it a dynamic string that requires contextual information?\nFor the former, we can use ",(0,r.kt)("a",{parentName:"li",href:"https://pkg.go.dev/github.com/go-faster/errors#New"},(0,r.kt)("inlineCode",{parentName:"a"},"errors.New")),", but for the latter we must\nuse ",(0,r.kt)("a",{parentName:"li",href:"https://pkg.go.dev/github.com/go-faster/errors#Errorf"},(0,r.kt)("inlineCode",{parentName:"a"},"errors.Errorf"))," or a custom error type."),(0,r.kt)("li",{parentName:"ul"},"Are we propagating a new error returned by a downstream function?\nIf so, see the ",(0,r.kt)("a",{parentName:"li",href:"#error-wrapping"},"section on error wrapping"),".")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Error matching?"),(0,r.kt)("th",{parentName:"tr",align:null},"Error Message"),(0,r.kt)("th",{parentName:"tr",align:null},"Guidance"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"static"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://pkg.go.dev/github.com/go-faster/errors#New"},(0,r.kt)("inlineCode",{parentName:"a"},"errors.New")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"dynamic"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://pkg.go.dev/github.com/go-faster/errors#Errorf"},(0,r.kt)("inlineCode",{parentName:"a"},"errors.Errorf")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"static"),(0,r.kt)("td",{parentName:"tr",align:null},"top-level ",(0,r.kt)("inlineCode",{parentName:"td"},"var")," with ",(0,r.kt)("a",{parentName:"td",href:"https://pkg.go.dev/github.com/go-faster/errors#New"},(0,r.kt)("inlineCode",{parentName:"a"},"errors.New")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"dynamic"),(0,r.kt)("td",{parentName:"tr",align:null},"custom ",(0,r.kt)("inlineCode",{parentName:"td"},"error")," type")))),(0,r.kt)("p",null,"For example,\nuse ",(0,r.kt)("a",{parentName:"p",href:"https://pkg.go.dev/github.com/go-faster/errors#New"},(0,r.kt)("inlineCode",{parentName:"a"},"errors.New"))," for an error with a static string.\nExport this error as a variable to support matching it with ",(0,r.kt)("inlineCode",{parentName:"p"},"errors.Is"),"\nif the caller needs to match and handle this error."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"No error matching"),(0,r.kt)("th",null,"Error matching"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'// package foo\n\nfunc Open() error {\n  return errors.New("could not open")\n}\n\n// package bar\n\nif err := foo.Open(); err != nil {\n  // Can\'t handle the error.\n  panic("unknown error")\n}\n'))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'// package foo\n\nvar ErrCouldNotOpen = errors.New("could not open")\n\nfunc Open() error {\n  return ErrCouldNotOpen\n}\n\n// package bar\n\nif err := foo.Open(); err != nil {\n  if errors.Is(err, foo.ErrCouldNotOpen) {\n    // handle the error\n  } else {\n    panic("unknown error")\n  }\n}\n')))))),(0,r.kt)("p",null,"For an error with a dynamic string,\nuse ","[",(0,r.kt)("inlineCode",{parentName:"p"},"errors.Wrap"),"]"," if the caller does not need to match it,\nand a custom ",(0,r.kt)("inlineCode",{parentName:"p"},"error")," if the caller does need to match it."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"No error matching"),(0,r.kt)("th",null,"Error matching"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'// package foo\n\nfunc Open(file string) error {\n  return errors.Errorf("file %q not found", file)\n}\n\n// package bar\n\nif err := foo.Open("testfile.txt"); err != nil {\n  // Can\'t handle the error.\n  panic("unknown error")\n}\n'))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'// package foo\n\ntype NotFoundError struct {\n  File string\n}\n\nfunc (e *NotFoundError) Error() string {\n  return fmt.Sprintf("file %q not found", e.File)\n}\n\nfunc Open(file string) error {\n  return &NotFoundError{File: file}\n}\n\n\n// package bar\n\nif err := foo.Open("testfile.txt"); err != nil {\n  var notFound *NotFoundError\n  if errors.As(err, &notFound) {\n    // handle the error\n  } else {\n    panic("unknown error")\n  }\n}\n')))))),(0,r.kt)("p",null,"Note that if you export error variables or types from a package,\nthey will become part of the public API of the package."),(0,r.kt)("h3",{id:"error-wrapping"},"Error Wrapping"),(0,r.kt)("p",null,"There are two main options for propagating errors if a call fails:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"return the original error as-is"),(0,r.kt)("li",{parentName:"ul"},"add context with ",(0,r.kt)("inlineCode",{parentName:"li"},"errors.Wrap")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"errors.Wrapf"))),(0,r.kt)("p",null,"Return the original error as-is if there is no additional context to add.\nThis maintains the original error type and message.\nThis is well suited for cases when the underlying error message\nhas sufficient information to track down where it came from."),(0,r.kt)("p",null,'Otherwise, add context to the error message where possible\nso that instead of a vague error such as "connection refused",\nyou get more useful errors such as "call service foo: connection refused".'),(0,r.kt)("p",null,"Use ",(0,r.kt)("inlineCode",{parentName:"p"},"errors.Wrap")," to add context to your errors."),(0,r.kt)("p",null,"Be aware that callers may begin to rely on this behavior.\nSo for cases where the wrapped error is a known ",(0,r.kt)("inlineCode",{parentName:"p"},"var")," or type,\ndocument and test it as part of your function's contract."),(0,r.kt)("p",null,'When adding context to returned errors, keep the context succinct by avoiding\nphrases like "failed to", which state the obvious and pile up as the error\npercolates up through the stack:'),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'s, err := store.New()\nif err != nil {\n    return errors.Wrap(err, "failed to create new store")\n}\n'))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'s, err := store.New()\nif err != nil {\n    return errors.Wrap(err, "new store")\n}\n')))),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"failed to x: failed to y: failed to create new store: the error\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"x: y: new store: the error\n")))))),(0,r.kt)("p",null,"However once the error is sent to another system, it should be clear the\nmessage is an error (e.g. an ",(0,r.kt)("inlineCode",{parentName:"p"},"err"),' tag or "Failed" prefix in logs).'),(0,r.kt)("p",null,"See also ",(0,r.kt)("a",{parentName:"p",href:"https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully"},"Don't just check errors, handle them gracefully"),"."),(0,r.kt)("h3",{id:"error-naming"},"Error Naming"),(0,r.kt)("p",null,"For error values stored as global variables,\nuse the prefix ",(0,r.kt)("inlineCode",{parentName:"p"},"Err")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"err")," depending on whether they're exported.\nThis guidance supersedes the ",(0,r.kt)("a",{parentName:"p",href:"#prefix-unexported-globals-with-_"},"Prefix Unexported Globals with _"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'var (\n  // The following two errors are exported\n  // so that users of this package can match them\n  // with errors.Is.\n\n  ErrBrokenLink = errors.New("link is broken")\n  ErrCouldNotOpen = errors.New("could not open")\n\n  // This error is not exported because\n  // we don\'t want to make it part of our public API.\n  // We may still use it inside the package\n  // with errors.Is.\n\n  errNotFound = errors.New("not found")\n)\n')),(0,r.kt)("p",null,"For custom error types, use the suffix ",(0,r.kt)("inlineCode",{parentName:"p"},"Error")," instead."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'// Similarly, this error is exported\n// so that users of this package can match it\n// with errors.As.\n\ntype NotFoundError struct {\n  File string\n}\n\nfunc (e *NotFoundError) Error() string {\n  return fmt.Sprintf("file %q not found", e.File)\n}\n\n// And this error is not exported because\n// we don\'t want to make it part of the public API.\n// We can still use it inside the package\n// with errors.As.\n\ntype resolveError struct {\n  Path string\n}\n\nfunc (e *resolveError) Error() string {\n  return fmt.Sprintf("resolve %q", e.Path)\n}\n')),(0,r.kt)("h2",{id:"handle-type-assertion-failures"},"Handle Type Assertion Failures"),(0,r.kt)("p",null,"The single return value form of a ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/ref/spec#Type_assertions"},"type assertion"),' will panic on an incorrect\ntype. Therefore, always use the "comma ok" idiom.'),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"t := i.(string)\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"t, ok := i.(string)\nif !ok {\n  // handle the error gracefully\n}\n")))))),(0,r.kt)("h2",{id:"dont-panic"},"Don't Panic"),(0,r.kt)("p",null,"Code running in production must avoid panics. Panics are a major source of\n",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Cascading_failure"},"cascading failures"),". If an error occurs, the function must return an error and\nallow the caller to decide how to handle it."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func run(args []string) {\n  if len(args) == 0 {\n    panic("an argument is required")\n  }\n  // ...\n}\n\nfunc main() {\n  run(os.Args[1:])\n}\n'))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func run(args []string) error {\n  if len(args) == 0 {\n    return errors.New("an argument is required")\n  }\n  // ...\n  return nil\n}\n\nfunc main() {\n  if err := run(os.Args[1:]); err != nil {\n    fmt.Fprintln(os.Stderr, err)\n    os.Exit(1)\n  }\n}\n')))))),(0,r.kt)("p",null,"Panic/recover is not an error handling strategy. A program must panic only when\nsomething irrecoverable happens such as a nil dereference. An exception to this is\nprogram initialization: bad things at program startup that should abort the\nprogram may cause panic."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'var _statusTemplate = template.Must(template.New("name").Parse("_statusHTML"))\n')),(0,r.kt)("p",null,"Even in tests, prefer ",(0,r.kt)("inlineCode",{parentName:"p"},"t.Fatal")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"t.FailNow")," over panics to ensure that the\ntest is marked as failed."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'// func TestFoo(t *testing.T)\n\nf, err := ioutil.TempFile("", "test")\nif err != nil {\n  panic("failed to set up test")\n}\n'))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'// func TestFoo(t *testing.T)\n\nf, err := ioutil.TempFile("", "test")\nif err != nil {\n  t.Fatal("failed to set up test")\n}\n')))))),(0,r.kt)("h2",{id:"use-gouberorgatomic"},"Use go.uber.org/atomic"),(0,r.kt)("p",null,"Atomic operations with the ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/pkg/sync/atomic/"},"sync/atomic")," package operate on the raw types\n(",(0,r.kt)("inlineCode",{parentName:"p"},"int32"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"int64"),", etc.) so it is easy to forget to use the atomic operation to\nread or modify the variables."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://godoc.org/go.uber.org/atomic"},"go.uber.org/atomic")," adds type safety to these operations by hiding the\nunderlying type. Additionally, it includes a convenient ",(0,r.kt)("inlineCode",{parentName:"p"},"atomic.Bool")," type."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type foo struct {\n  running int32  // atomic\n}\n\nfunc (f* foo) start() {\n  if atomic.SwapInt32(&f.running, 1) == 1 {\n     // already running\u2026\n     return\n  }\n  // start the Foo\n}\n\nfunc (f *foo) isRunning() bool {\n  return f.running == 1  // race!\n}\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type foo struct {\n  running atomic.Bool\n}\n\nfunc (f *foo) start() {\n  if f.running.Swap(true) {\n     // already running\u2026\n     return\n  }\n  // start the Foo\n}\n\nfunc (f *foo) isRunning() bool {\n  return f.running.Load()\n}\n")))))),(0,r.kt)("h2",{id:"avoid-mutable-globals"},"Avoid Mutable Globals"),(0,r.kt)("p",null,"Avoid mutating global variables, instead opting for dependency injection.\nThis applies to function pointers as well as other kinds of values."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// sign.go\n\nvar _timeNow = time.Now\n\nfunc sign(msg string) string {\n  now := _timeNow()\n  return signWithTime(msg, now)\n}\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// sign.go\n\ntype signer struct {\n  now func() time.Time\n}\n\nfunc newSigner() *signer {\n  return &signer{\n    now: time.Now,\n  }\n}\n\nfunc (s *signer) Sign(msg string) string {\n  now := s.now()\n  return signWithTime(msg, now)\n}\n")))),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// sign_test.go\n\nfunc TestSign(t *testing.T) {\n  oldTimeNow := _timeNow\n  _timeNow = func() time.Time {\n    return someFixedTime\n  }\n  defer func() { _timeNow = oldTimeNow }()\n\n  assert.Equal(t, want, sign(give))\n}\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// sign_test.go\n\nfunc TestSigner(t *testing.T) {\n  s := newSigner()\n  s.now = func() time.Time {\n    return someFixedTime\n  }\n\n  assert.Equal(t, want, s.Sign(give))\n}\n")))))),(0,r.kt)("h2",{id:"avoid-embedding-types-in-public-structs"},"Avoid Embedding Types in Public Structs"),(0,r.kt)("p",null,"These embedded types leak implementation details, inhibit type evolution, and\nobscure documentation."),(0,r.kt)("p",null,"Assuming you have implemented a variety of list types using a shared\n",(0,r.kt)("inlineCode",{parentName:"p"},"AbstractList"),", avoid embedding the ",(0,r.kt)("inlineCode",{parentName:"p"},"AbstractList")," in your concrete list\nimplementations.\nInstead, hand-write only the methods to your concrete list that will delegate\nto the abstract list."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type AbstractList struct {}\n\n// Add adds an entity to the list.\nfunc (l *AbstractList) Add(e Entity) {\n  // ...\n}\n\n// Remove removes an entity from the list.\nfunc (l *AbstractList) Remove(e Entity) {\n  // ...\n}\n")),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// ConcreteList is a list of entities.\ntype ConcreteList struct {\n  *AbstractList\n}\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// ConcreteList is a list of entities.\ntype ConcreteList struct {\n  list *AbstractList\n}\n\n// Add adds an entity to the list.\nfunc (l *ConcreteList) Add(e Entity) {\n  l.list.Add(e)\n}\n\n// Remove removes an entity from the list.\nfunc (l *ConcreteList) Remove(e Entity) {\n  l.list.Remove(e)\n}\n")))))),(0,r.kt)("p",null,"Go allows ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/doc/effective_go.html#embedding"},"type embedding")," as a compromise between inheritance and composition.\nThe outer type gets implicit copies of the embedded type's methods.\nThese methods, by default, delegate to the same method of the embedded\ninstance."),(0,r.kt)("p",null,"The struct also gains a field by the same name as the type.\nSo, if the embedded type is public, the field is public.\nTo maintain backward compatibility, every future version of the outer type must\nkeep the embedded type."),(0,r.kt)("p",null,"An embedded type is rarely necessary.\nIt is a convenience that helps you avoid writing tedious delegate methods."),(0,r.kt)("p",null,"Even embedding a compatible AbstractList ",(0,r.kt)("em",{parentName:"p"},"interface"),", instead of the struct,\nwould offer the developer more flexibility to change in the future, but still\nleak the detail that the concrete lists use an abstract implementation."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// AbstractList is a generalized implementation\n// for various kinds of lists of entities.\ntype AbstractList interface {\n  Add(Entity)\n  Remove(Entity)\n}\n\n// ConcreteList is a list of entities.\ntype ConcreteList struct {\n  AbstractList\n}\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// ConcreteList is a list of entities.\ntype ConcreteList struct {\n  list AbstractList\n}\n\n// Add adds an entity to the list.\nfunc (l *ConcreteList) Add(e Entity) {\n  l.list.Add(e)\n}\n\n// Remove removes an entity from the list.\nfunc (l *ConcreteList) Remove(e Entity) {\n  l.list.Remove(e)\n}\n")))))),(0,r.kt)("p",null,"Either with an embedded struct or an embedded interface, the embedded type\nplaces limits on the evolution of the type."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Adding methods to an embedded interface is a breaking change."),(0,r.kt)("li",{parentName:"ul"},"Removing methods from an embedded struct is a breaking change."),(0,r.kt)("li",{parentName:"ul"},"Removing the embedded type is a breaking change."),(0,r.kt)("li",{parentName:"ul"},"Replacing the embedded type, even with an alternative that satisfies the same\ninterface, is a breaking change.")),(0,r.kt)("p",null,"Although writing these delegate methods is tedious, the additional effort hides\nan implementation detail, leaves more opportunities for change, and also\neliminates indirection for discovering the full List interface in\ndocumentation."),(0,r.kt)("h2",{id:"avoid-using-built-in-names"},"Avoid Using Built-In Names"),(0,r.kt)("p",null,"The Go ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/ref/spec"},"language specification")," outlines several built-in,\n",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/ref/spec#Predeclared_identifiers"},"predeclared identifiers")," that should not be used as names within Go programs."),(0,r.kt)("p",null,"Depending on context, reusing these identifiers as names will either shadow\nthe original within the current lexical scope (and any nested scopes) or make\naffected code confusing. In the best case, the compiler will complain; in the\nworst case, such code may introduce latent, hard-to-grep bugs."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"var error string\n// `error` shadows the builtin\n\n// or\n\nfunc handleErrorMessage(error string) {\n    // `error` shadows the builtin\n}\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"var errorMessage string\n// `error` refers to the builtin\n\n// or\n\nfunc handleErrorMessage(msg string) {\n    // `error` refers to the builtin\n}\n")))),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type Foo struct {\n    // While these fields technically don't\n    // constitute shadowing, grepping for\n    // `error` or `string` strings is now\n    // ambiguous.\n    error  error\n    string string\n}\n\nfunc (f Foo) Error() error {\n    // `error` and `f.error` are\n    // visually similar\n    return f.error\n}\n\nfunc (f Foo) String() string {\n    // `string` and `f.string` are\n    // visually similar\n    return f.string\n}\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type Foo struct {\n    // `error` and `string` strings are\n    // now unambiguous.\n    err error\n    str string\n}\n\nfunc (f Foo) Error() error {\n    return f.err\n}\n\nfunc (f Foo) String() string {\n    return f.str\n}\n")))))),(0,r.kt)("p",null,"Note that the compiler will not generate errors when using predeclared\nidentifiers, but tools such as ",(0,r.kt)("inlineCode",{parentName:"p"},"go vet")," should correctly point out these and\nother cases of shadowing."),(0,r.kt)("h2",{id:"avoid-init"},"Avoid ",(0,r.kt)("inlineCode",{parentName:"h2"},"init()")),(0,r.kt)("p",null,"Avoid ",(0,r.kt)("inlineCode",{parentName:"p"},"init()")," where possible. When ",(0,r.kt)("inlineCode",{parentName:"p"},"init()")," is unavoidable or desirable, code\nshould attempt to:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Be completely deterministic, regardless of program environment or invocation."),(0,r.kt)("li",{parentName:"ol"},"Avoid depending on the ordering or side-effects of other ",(0,r.kt)("inlineCode",{parentName:"li"},"init()")," functions.\nWhile ",(0,r.kt)("inlineCode",{parentName:"li"},"init()")," ordering is well-known, code can change, and thus\nrelationships between ",(0,r.kt)("inlineCode",{parentName:"li"},"init()")," functions can make code brittle and\nerror-prone."),(0,r.kt)("li",{parentName:"ol"},"Avoid accessing or manipulating global or environment state, such as machine\ninformation, environment variables, working directory, program\narguments/inputs, etc."),(0,r.kt)("li",{parentName:"ol"},"Avoid I/O, including both filesystem, network, and system calls.")),(0,r.kt)("p",null,"Code that cannot satisfy these requirements likely belongs as a helper to be\ncalled as part of ",(0,r.kt)("inlineCode",{parentName:"p"},"main()")," (or elsewhere in a program's lifecycle), or be\nwritten as part of ",(0,r.kt)("inlineCode",{parentName:"p"},"main()"),' itself. In particular, libraries that are intended\nto be used by other programs should take special care to be completely\ndeterministic and not perform "init magic".'),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"type Foo struct {\n    // ...\n}\n\nvar _defaultFoo Foo\n\nfunc init() {\n    _defaultFoo = Foo{\n        // ...\n    }\n}\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"var _defaultFoo = Foo{\n    // ...\n}\n\n// or, better, for testability:\n\nvar _defaultFoo = defaultFoo()\n\nfunc defaultFoo() Foo {\n    return Foo{\n        // ...\n    }\n}\n")))),(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'type Config struct {\n    // ...\n}\n\nvar _config Config\n\nfunc init() {\n    // Bad: based on current directory\n    cwd, _ := os.Getwd()\n\n    // Bad: I/O\n    raw, _ := ioutil.ReadFile(\n        path.Join(cwd, "config", "config.yaml"),\n    )\n\n    yaml.Unmarshal(raw, &_config)\n}\n'))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'type Config struct {\n    // ...\n}\n\nfunc loadConfig() Config {\n    cwd, err := os.Getwd()\n    // handle err\n\n    raw, err := ioutil.ReadFile(\n        path.Join(cwd, "config", "config.yaml"),\n    )\n    // handle err\n\n    var config Config\n    yaml.Unmarshal(raw, &config)\n\n    return config\n}\n')))))),(0,r.kt)("p",null,"Considering the above, some situations in which ",(0,r.kt)("inlineCode",{parentName:"p"},"init()")," may be preferable or\nnecessary might include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Complex expressions that cannot be represented as single assignments.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Pluggable hooks, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"database/sql")," dialects, encoding type registries, etc.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Optimizations to ",(0,r.kt)("a",{parentName:"p",href:"https://cloud.google.com/functions/docs/bestpractices/tips#use_global_variables_to_reuse_objects_in_future_invocations"},"Google Cloud Functions")," and other forms of deterministic\nprecomputation."))),(0,r.kt)("h2",{id:"exit-in-main"},"Exit in Main"),(0,r.kt)("p",null,"Go programs use ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/pkg/os/#Exit"},(0,r.kt)("inlineCode",{parentName:"a"},"os.Exit"))," or ",(0,r.kt)("a",{parentName:"p",href:"https://golang.org/pkg/log/#Fatal"},(0,r.kt)("inlineCode",{parentName:"a"},"log.Fatal*"))," to exit immediately. (Panicking\nis not a good way to exit programs, please ",(0,r.kt)("a",{parentName:"p",href:"#dont-panic"},"don't panic"),".)"),(0,r.kt)("p",null,"Call one of ",(0,r.kt)("inlineCode",{parentName:"p"},"os.Exit")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"log.Fatal*")," ",(0,r.kt)("strong",{parentName:"p"},"only in ",(0,r.kt)("inlineCode",{parentName:"strong"},"main()")),". All other\nfunctions should return errors to signal failure."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func main() {\n  body := readFile(path)\n  fmt.Println(body)\n}\n\nfunc readFile(path string) string {\n  f, err := os.Open(path)\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  b, err := ioutil.ReadAll(f)\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  return string(b)\n}\n"))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n  body, err := readFile(path)\n  if err != nil {\n    log.Fatal(err)\n  }\n  fmt.Println(body)\n}\n\nfunc readFile(path string) (string, error) {\n  f, err := os.Open(path)\n  if err != nil {\n    return "", err\n  }\n\n  b, err := ioutil.ReadAll(f)\n  if err != nil {\n    return "", err\n  }\n\n  return string(b), nil\n}\n')))))),(0,r.kt)("p",null,"Rationale: Programs with multiple functions that exit present a few issues:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Non-obvious control flow: Any function can exit the program so it becomes\ndifficult to reason about the control flow."),(0,r.kt)("li",{parentName:"ul"},"Difficult to test: A function that exits the program will also exit the test\ncalling it. This makes the function difficult to test and introduces risk of\nskipping other tests that have not yet been run by ",(0,r.kt)("inlineCode",{parentName:"li"},"go test"),"."),(0,r.kt)("li",{parentName:"ul"},"Skipped cleanup: When a function exits the program, it skips function calls\nenqueued with ",(0,r.kt)("inlineCode",{parentName:"li"},"defer")," statements. This adds risk of skipping important\ncleanup tasks.")),(0,r.kt)("h3",{id:"exit-once"},"Exit Once"),(0,r.kt)("p",null,"If possible, prefer to call ",(0,r.kt)("inlineCode",{parentName:"p"},"os.Exit")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"log.Fatal")," ",(0,r.kt)("strong",{parentName:"p"},"at most once")," in your\n",(0,r.kt)("inlineCode",{parentName:"p"},"main()"),". If there are multiple error scenarios that halt program execution,\nput that logic under a separate function and return errors from it."),(0,r.kt)("p",null,"This has the effect of shortening your ",(0,r.kt)("inlineCode",{parentName:"p"},"main()")," function and putting all key\nbusiness logic into a separate, testable function."),(0,r.kt)("table",null,(0,r.kt)("thead",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Bad"),(0,r.kt)("th",null,"Good"))),(0,r.kt)("tbody",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nfunc main() {\n  args := os.Args[1:]\n  if len(args) != 1 {\n    log.Fatal("missing file")\n  }\n  name := args[0]\n\n  f, err := os.Open(name)\n  if err != nil {\n    log.Fatal(err)\n  }\n  defer f.Close()\n\n  // If we call log.Fatal after this line,\n  // f.Close will not be called.\n\n  b, err := ioutil.ReadAll(f)\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  // ...\n}\n'))),(0,r.kt)("td",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nfunc main() {\n  if err := run(); err != nil {\n    log.Fatal(err)\n  }\n}\n\nfunc run() error {\n  args := os.Args[1:]\n  if len(args) != 1 {\n    return errors.New("missing file")\n  }\n  name := args[0]\n\n  f, err := os.Open(name)\n  if err != nil {\n    return err\n  }\n  defer f.Close()\n\n  b, err := ioutil.ReadAll(f)\n  if err != nil {\n    return err\n  }\n\n  // ...\n}\n')))))))}d.isMDXComponent=!0}}]);